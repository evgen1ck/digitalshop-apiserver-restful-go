package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"errors"
	"fmt"
	"github.com/jackc/pgx/v4"
	"strings"
	"test-server-go/graph/model"
	"test-server-go/internal/models"
	"test-server-go/internal/tools"
	v "test-server-go/internal/validator"
)

// AuthSignupWithoutCode is the resolver for the authSignupWithoutCode field.
func (r *mutationResolver) AuthSignupWithoutCode(ctx context.Context, input model.SignupWithoutCodeInput) (bool, error) {
	// Block 1
	nickname := strings.TrimSpace(input.Nickname)
	email := strings.TrimSpace(input.Email)
	password := strings.TrimSpace(input.Password)

	if err := v.Validate(nickname, v.IsMinMaxLen(6, 64), v.IsContainsSpaces()); err != nil {
		return false, errors.New("nickname: " + err.Error())
	}
	if err := v.Validate(email, v.IsMinMaxLen(6, 64), v.IsContainsSpaces(), v.IsEmail()); err != nil {
		return false, errors.New("email: " + err.Error())
	}
	if err := v.Validate(password, v.IsMinMaxLen(6, 64), v.IsContainsSpaces()); err != nil {
		return false, errors.New("password: " + err.Error())
	}

	// Block 2
	result := execInTx(ctx, r.App.Postgres.Pool, r.App.Logrus, func(tx pgx.Tx) (interface{}, error) {
		var result models.ExistsNicknameEmail
		err := tx.QueryRow(ctx,
			"SELECT EXISTS(SELECT 1 FROM account.user WHERE nickname = $1)::boolean AS username_exists, EXISTS(SELECT 1 FROM account.user WHERE email = $2)::boolean AS email_exists",
			nickname, email).Scan(&result.NicknameExists, &result.EmailExists)
		return result, err
	})
	existsAccount := result.(models.ExistsNicknameEmail)
	if existsAccount.NicknameExists {
		return false, errors.New("this nickname is already in use")
	}
	if existsAccount.EmailExists {
		return false, errors.New("this email is already in use")
	}

	// Block 3
	confirmCode, err := tools.GenerateConfirmCode()
	if err != nil {
		r.App.Logrus.NewError("the confirm code not generated", err)
	}

	result = execInTx(ctx, r.App.Postgres.Pool, r.App.Logrus, func(tx pgx.Tx) (interface{}, error) {
		var resultRegistrationTempNo bool
		err = tx.QueryRow(ctx,
			"INSERT INTO account.registration_temp(nickname, email, password, confirmation_code) VALUES ($1, $2, $3, $4) RETURNING EXISTS(SELECT 1 FROM account.registration_temp WHERE registration_temp_no = registration_temp_no) AS result;",
			nickname, email, password, confirmCode).Scan(&resultRegistrationTempNo)

		return resultRegistrationTempNo, nil
	})

	return result.(bool), nil
}

// AuthSignupWithCode is the resolver for the authSignupWithCode field.
func (r *mutationResolver) AuthSignupWithCode(ctx context.Context, input model.SignupWithCodeInput) (*model.AuthPayload, error) {
	panic(fmt.Errorf("not implemented: AuthSignupWithCode - authSignupWithCode"))
}

// AuthLogin is the resolver for the authLogin field.
func (r *mutationResolver) AuthLogin(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	panic(fmt.Errorf("not implemented: AuthLogin - authLogin"))
}

// AuthLogout is the resolver for the authLogout field.
func (r *mutationResolver) AuthLogout(ctx context.Context, input model.TokenInput) (bool, error) {
	panic(fmt.Errorf("not implemented: AuthLogout - authLogout"))
}

// AuthTokenValidate is the resolver for the authTokenValidate field.
func (r *mutationResolver) AuthTokenValidate(ctx context.Context, input model.TokenInput) (bool, error) {
	panic(fmt.Errorf("not implemented: AuthTokenValidate - authTokenValidate"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
